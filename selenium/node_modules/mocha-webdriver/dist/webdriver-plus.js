"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const selenium_webdriver_1 = require("selenium-webdriver");
async function findContentHelper(driver, finder, selector, contentRE) {
    return await driver.executeScript(() => {
        const finder = (arguments[0] || window.document);
        const elements = [...finder.querySelectorAll(arguments[1])];
        const contentRE = new RegExp(arguments[2]);
        const found = elements.find((el) => contentRE.test(el.innerText));
        if (!found) {
            throw new Error(`None of ${elements.length} elements match ${contentRE}`);
        }
        return found;
    }, finder, selector, contentRE.source);
}
// Enhance WebDriver to implement IWebDriverPlus interface.
Object.assign(selenium_webdriver_1.WebDriver.prototype, {
    find(selector) {
        return this.findElement(selenium_webdriver_1.By.css(selector));
    },
    async findAll(selector, mapper) {
        const elems = await this.findElements(selenium_webdriver_1.By.css(selector));
        return mapper ? Promise.all(elems.map(mapper)) : elems;
    },
    findWait(timeoutSec, selector, message) {
        return this.wait(selenium_webdriver_1.until.elementLocated(selenium_webdriver_1.By.css(selector)), timeoutSec * 1000, message);
    },
    findContent(selector, contentRE) {
        return new selenium_webdriver_1.WebElementPromise(this, findContentHelper(this, null, selector, contentRE));
    },
});
// Enhance WebElement to implement IWebElementPlus interface.
Object.assign(selenium_webdriver_1.WebElement.prototype, {
    find(selector) {
        return this.findElement(selenium_webdriver_1.By.css(selector));
    },
    async findAll(selector, mapper) {
        const elems = await this.findElements(selenium_webdriver_1.By.css(selector));
        return mapper ? Promise.all(elems.map(mapper)) : elems;
    },
    findWait(timeoutSec, selector, message) {
        const condition = new selenium_webdriver_1.WebElementCondition(`for element matching ${selector}`, () => this.findElements(selenium_webdriver_1.By.css(selector)).then((e) => e[0]));
        return this.getDriver().wait(condition, timeoutSec * 1000, message);
    },
    findContent(selector, contentRE) {
        return new selenium_webdriver_1.WebElementPromise(this.getDriver(), findContentHelper(this.getDriver(), this, selector, contentRE));
    },
    doClick() {
        return new selenium_webdriver_1.WebElementPromise(this.getDriver(), this.click().then(() => this));
    },
    doSendKeys(...args) {
        return new selenium_webdriver_1.WebElementPromise(this.getDriver(), this.sendKeys(...args).then(() => this));
    },
    doSubmit() {
        return new selenium_webdriver_1.WebElementPromise(this.getDriver(), this.submit().then(() => this));
    },
    doClear() {
        return new selenium_webdriver_1.WebElementPromise(this.getDriver(), this.clear().then(() => this));
    },
    value() {
        return this.getAttribute('value');
    },
    async describe() {
        const [elemId, id, tagName, classAttr] = await Promise.all([
            this.getId(), this.getAttribute('id'), this.getTagName(), this.getAttribute('class'),
        ]);
        const idStr = id ? '#' + id : '';
        const classes = classAttr ? '.' + classAttr.replace(/ /g, '.') : '';
        return `${tagName}${idStr}${classes}[${elemId}]`;
    },
});
//# sourceMappingURL=webdriver-plus.js.map